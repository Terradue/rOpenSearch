# Occurrences

#### Load the required packages with:

```{r warning=FALSE, error=FALSE, message=FALSE}
library("devtools")
library("rgbif")
library("fpc")
library("httr")
library("stringr")
library("XML")
library("RCurl")
library("sp")
library("rgeos") 
library("maps") 
library("RColorBrewer")
#library("mapdata") 
library("rOpenSearch")
library("rgbif")
library("knitr")
library("rworldmap")
```

#### Getting the White Shark occurrences from GBIF with rgbif

```{r}
# get the occurrences from GBIF using rgbif
key <- name_backbone(name='Carcharodon carcharias', kingdom='animalia')$speciesKey
occurrences <- occ_search(taxonKey=key, limit=1000, return='data', hasCoordinate=TRUE)
occurrences <- occurrences[complete.cases(occurrences),]
```

This create the data frame occ with `r nrow(occurrences)` entries. The first five entries look like:

```{r results='asis', echo=FALSE}
kable(head(occurrences, 5), format = "html")
```

The occurrences can be plotted to create the map:

```{r results='asis', message=FALSE, echo=FALSE}
gbifmap(occurrences)
```

Apply the DBSCAN clustering algorithm to identify representative occurence clusters.

```{r}
occurrences <- cbind(occurrences$decimalLongitude, occurrences$decimalLatitude)

eps <- 5
minpts <- 20
dbscan.res <- dbscan(occurrences, eps=eps, MinPts=minpts)
```

The DBSCAN algorithm identified `r max(dbscan.res$cluster)` geographical clusters.

For each cluster the minimum bounding box is identified and plot.

```{r}
mbr <- list()
plot(getMap())

#extract the minimum bounding box for each cluster
for(i in 1:max(dbscan.res$cluster)) {

 # get the cluster
 cl <- (occurrences[dbscan.res$cluster %in% i,])
  
 # create the matrix with the cluster minimum bounding box
 coords <- matrix(nrow=5, ncol=2, byrow=TRUE, data=c(
  min(cl[,1]), min(cl[,2]),
  max(cl[,1]), min(cl[,2]),
  max(cl[,1]), max(cl[,2]),
  min(cl[,1]), max(cl[,2]),
  min(cl[,1]), min(cl[,2])))
  
  # get the cluster geospatial envelope
  if (gArea(gEnvelope(SpatialPoints(coords)))>0) mbr[[length(mbr)+1]] <- gEnvelope(SpatialPoints(coords))

  plot(mbr[[length(mbr)]], add=TRUE, col="red")
}

plot(occurrences, add=TRUE, col=dbscan.res$cluster)
```

#### Querying Envisat MERIS Level 1 data over a cluster

ESA hosts an OpenSearch catalogue available at: http://grid-eo-catalog.esrin.esa.int/catalogue/gpod/rdf

We will work with Envisat MERIS Full Resolution data and use the catalogue response type "application/rdf+xml".

```{r}
# set the catalogue and retrieve the queryables
osd.description <- 'http://grid-eo-catalog.esrin.esa.int/catalogue/gpod/MER_FRS_1P/description'
response.type <- "application/rdf+xml"
q <- GetOSQueryables(osd.description, response.type)
```

q is a data frame containing:

```{r results='asis', echo=FALSE}
kable(q, format = "html")
```

Let's set the **count** field type value to `r count <- 200; count`:

```{r}
q$value[q$type == "count"] <- count
```

and set out time of interest by setting the value of the field types **time:start**, **time:end** with:

```{r}
q$value[q$type == "time:start"] <- "2006-01-01"
q$value[q$type == "time:end"] <- "2006-12-31"
```

q is now updated with:

```{r results='asis', echo=FALSE}
kable(q, format = "html")
```

```{r}
q$value[q$type == "geo:geometry"] <- writeWKT(mbr[[1]])
```

q is now updated with (removing NAs for readability):

```{r results='asis', echo=FALSE}
kable(q[complete.cases(q),], format = "html")
```

Let's query the catalogue and apply an xpath expression to retrieve the datasets as a data frame:

```{r}
res <- Query(osd.description, response.type, q)
```

From the result, get the Datasets

```{r}
dataset <- xmlToDataFrame(nodes = getNodeSet(xmlParse(res), "//dclite4g:DataSet"), stringsAsFactors = FALSE)
```

Let's inspect the first datasets:

```{r results='asis', echo=FALSE}
kable(head(dataset, 5), format = "html")
```

We now create a SpatialPolygonsDataFrame:  
```{r}
poly.sp <- SpatialPolygonsDataFrame(readWKT(data.frame(dataset$spatial)[1,]), dataset[1,])

for (n in 2:nrow(dataset)) {
 poly.sp <- rbind(poly.sp, SpatialPolygonsDataFrame(readWKT(data.frame(dataset$spatial)[n,],id=n), dataset[n,]))  
} 
```

And check the coverage index of the MERIS products wrt the cluster minimum bounding box:

```{r}
for (n in 1:nrow(dataset)) {
 poly.sp[n,"coverage_index"] <- gArea(gIntersection(mbr[[1]], poly.sp[n,])) / gArea(mbr[[1]]) 
}
```

Select those with a coverage over 80%:

```{r}
sp <- poly.sp[poly.sp$coverage_index > 0.8,]
```

Let's plot it:

```{r}
plot(getMap())
plot(sp, add=TRUE, col=brewer.pal( 8 , "RdBu")[1])
plot(mbr[[1]], add=TRUE, col="blue")
```

Done!
